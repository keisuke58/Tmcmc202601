# 重要な発見：M3問題の根本原因

## ✅ 確認結果

### 1. M3のデータ生成元
**→ M3モデルから独立に生成されている（M1からではない）**

- 実行結果のデータと再生成データが完全一致
- インデックス、時間配列も一致

### 2. ⚠️ 時間スケールの重大な違い

| モデル | 時間範囲 | ステップ数 | 時間範囲比 |
|--------|---------|-----------|-----------|
| **M1** | 0.025 | 2501 | 1.0 |
| **M3** | **0.075** | 751 | **3.0** |

**M1とM3で異なる時間スケールを使用している**

### 3. 正規化時間
- 正規化時間はほぼ一致（Max difference: 0.0007）
- しかし、**実時間が3倍異なる**

## 🔴 問題の本質

**正規化時間を使うと見た目は揃うが、実時間が異なるため、ダイナミクス自体が変わる**

- M1: 0.025秒までのダイナミクス
- M3: 0.075秒までのダイナミクス（3倍長い）

→ **「同じデータを説明できない」状況が起きる**

## 📋 次のステップ（優先順位順）

### テストA：同じt_arr上で比較（最優先）

**目的**: 時間スケール差が原因かを確認

**方法**:
1. データ生成時のt_arrを固定（例：M1のt_arrを使用）
2. M3側も同じt_arrで出力（補間が必要）
3. これでズレが減るなら **時間軸が主因**

### テストB：尤度の重みをspeciesで正規化

**目的**: 「値の大きいspeciesに引っ張られる」問題を排除

**方法**:
- speciesごとに残差を `/(sigma_obs)` で正規化（既に実装済みか確認）
- speciesごとに `/(std(data_species))` で正規化（スケール差を吸収）
- species別sigma_obsを導入（φ4だけ合わない等を吸収）

### テストC：Posterior Predictive Check

**目的**: 論文と同じ評価方法で確認

**方法**:
- Posterior predictive bandで可視化
- どのspeciesがどのように外れているかを定量化

## 🎯 結論の修正

| 以前の結論 | より正確には |
|-----------|------------|
| 時間正規化は主要因ではない | **"正規化定義のミス"ではない**が、**時間スケール差 (0.025 vs 0.075)** が適合性に強く影響しうる |

## 📝 コード上の確認ポイント

### データ生成
```python
# main/case2_main.py:891
data_M3, idx_M3, t_M3, x0_M3, sig2_M3 = generate_synthetic_data(
    MODEL_CONFIGS["M3"], theta_true, exp_config, "M3", plot_mgr
)
```
→ M3から独立に生成（✅ 正しい）

### 尤度計算
```python
# 尤度計算時に新しいt_arrが生成される
t_arr, x0, sig2 = tsm.solve_tsm(theta)
```
→ このt_arrが`t_M3`と一致するか確認が必要

### 時間補間
```python
# main/case2_main.py:1651-1660
if len(t_fit) != len(t_M3) or not np.allclose(t_fit, t_M3):
    # 補間処理
```
→ 時間配列が異なる場合、補間が行われる

## 🔍 推奨される調査

1. **尤度計算時のt_arr確認**
   - データ生成時の`t_M3`と尤度計算時の`t_arr`が一致しているか
   - 一致しない場合、補間が正しく行われているか

2. **同じt_arr上での比較テスト**
   - M1のt_arrをM3でも使用（補間）
   - ズレが減るか確認

3. **Species別の残差分析**
   - どのspeciesが特に外れているか
   - φ3, φ4が特に外れる場合、これらのspeciesのデータ点が適切に使われているか
