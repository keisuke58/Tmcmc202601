# M3モデル問題 - 完全診断レポート

## 実行サマリー

### 実施した診断

1. ✅ **データ生成元の確認** (`check_m3_data_source.py`)
   - M3のデータはM3モデルから独立に生成されている（M1からではない）

2. ✅ **テストA: 同じt_arr上で比較** (`test_same_tarr_comparison.py`)
   - 結果: 同じt_arrでもズレは変わらない → **時間軸以外が主因**

3. ✅ **テストB: 尤度の重み正規化** (`test_species_weight_normalization.py`)
   - 結果: Species間の差は中程度（主要因ではない）

4. ✅ **詳細残差分析** (`analyze_m3_residuals.py`)
   - Species 3 (φ̄4)の残差RMSEが小さい（0.0057）
   - Species 2 (φ̄3)の後半で残差が大きくなる（後半/前半比: 1.43）
   - RMSE比率 (max/min): 1.92

5. ✅ **M3モデル構造の確認** (`check_m3_model_structure.py`)
   - M3は4つのspeciesをモデル化しているが、パラメータは4つだけ（結合項のみ）
   - M1とM2のパラメータは固定されている（階層的ベイズアプローチ）

6. ⏳ **M1/M2推定誤差の確認** (`check_m1_m2_estimation_error.py`)
   - 実行が完了次第確認が必要

## 重要な発見

### 1. M3モデル構造の問題

**構造**:
- M1: 5パラメータ（species 0, 1）
- M2: 5パラメータ（species 2, 3）
- M3: 4パラメータ（種間相互作用のみ: a13, a14, a23, a24）

**問題点**:
- M3は4つのspeciesをモデル化しているが、パラメータは4つだけ
- M1とM2のパラメータが固定されているため、柔軟性が低い
- **M1/M2の推定誤差がM3に伝播する可能性が高い**

### 2. データ生成と推定の不整合

**データ生成時**:
- theta_trueの全14パラメータを使用

**M3推定時**:
- M1/M2のMAP推定値 + M3パラメータのみ
- この不整合が残差の原因の可能性

### 3. 残差の特徴

**Species別の残差RMSE**:
- Species 0: 0.0109
- Species 1: 0.0109
- Species 2: 0.0106
- Species 3: 0.0057（最小）

**時間依存性**:
- Species 2の後半/前半比: 1.43（後半で残差が大きくなる）

## 原因候補ランキング（確度順）

### ① M1/M2の推定誤差がM3に伝播 ⭐ 最優先

**根拠**:
- M3推定時にM1/M2のMAP推定値を使用
- データ生成時はtheta_trueを使用
- この不整合が残差の原因の可能性が高い

**確認方法**:
- M1/M2のMAP/Meanがtheta_trueにどれだけ近いか
- M3推定時のベース誤差がどれくらいか

**対策**:
- M1/M2の推定精度を向上させる
- M3データ生成時にM1/M2推定結果を使用（一貫性の確保）

### ② M3モデルの構造ミスマッチ

**根拠**:
- 4つのspeciesを4つのパラメータだけでモデル化
- M1/M2のパラメータが固定されているため、柔軟性が低い

**確認方法**:
- M3で推定するパラメータの範囲を拡大した場合の改善を確認

**対策**:
- M3で推定するパラメータを増やす
- または、M1/M2の不確実性をM3に伝播（階層的ベイズ）

### ③ 校正に使ったデータ点が一部speciesのみ支配

**根拠**:
- Species 3の残差が小さい（よく適合）
- Species 2の後半で残差が大きくなる

**確認方法**:
- 各speciesの尤度への寄与度を確認
- データ点の分布を確認

**対策**:
- Species別の重み正規化
- Species別のsigma_obs導入

### ④ 時間正規化の不整合

**根拠**:
- M1とM3で異なる時間スケール（0.025 vs 0.075）
- テストAの結果、同じt_arrでもズレは変わらない

**判定**:
- **主要因ではない**（テストAで確認済み）

## 推奨される次のステップ

### 即座に実施すべき

1. **M1/M2推定誤差の確認**（実行完了後）
   ```bash
   python check_m1_m2_estimation_error.py
   ```

2. **M3データ生成と推定の一貫性確認**
   - データ生成時にM1/M2推定結果を使用するオプションを追加
   - または、M3推定時にtheta_trueを使用する（理想的なケース）

### 中期的対策

1. **M1/M2の推定精度向上**
   - パーティクル数: 1000 → 5000
   - ステージ数: 50 → 100

2. **Posterior Predictive Check**
   - M3のposterior predictive bandを可視化
   - データが予測区間内に収まっているか確認

### 長期的対策

1. **階層的ベイズの完全実装**
   - M1/M2の不確実性をM3に伝播
   - 統合的な尤度設計

2. **モデル構造の見直し**
   - M3で推定するパラメータの範囲を拡大
   - または、M3データ生成時にM1/M2推定結果を使用

## 作成したファイル

### 診断スクリプト
1. `check_m3_data_source.py` - データ生成元の確認 ✅
2. `test_same_tarr_comparison.py` - テストA（同じt_arr上で比較）✅
3. `test_species_weight_normalization.py` - テストB（尤度重み正規化）✅
4. `analyze_m3_residuals.py` - 詳細残差分析 ✅
5. `check_m3_model_structure.py` - M3モデル構造の確認 ✅
6. `check_m1_m2_estimation_error.py` - M1/M2推定誤差の確認 ⏳

### ドキュメント
1. `DIAGNOSIS_RESULT.md` - 初期診断結果
2. `FINAL_DIAGNOSIS.md` - 最終診断結果
3. `SUMMARY.md` - サマリー
4. `NEXT_STEPS.md` - 次のステップ
5. `DIAGNOSIS_COMPLETE.md` - 完全診断レポート（本ファイル）

## 結論

**最も可能性が高い原因**: **M1/M2の推定誤差がM3に伝播**

**確認方法**: 実行完了後、`check_m1_m2_estimation_error.py`を実行してM1/M2の推定誤差を確認

**対策**: M1/M2の推定精度を向上させる、またはM3データ生成時にM1/M2推定結果を使用（一貫性の確保）
