#!/usr/bin/env python3
"""
p10_bc_sensitivity.py  –  [P10] BC type sensitivity: force vs displacement control
====================================================================================

Under force-controlled BCs (current): MISES is load-geometry dominated (same for
all conditions); displacement differs by E_eff ratio.

Under displacement-controlled BCs: strain is fixed; MISES ∝ E_eff (conditions differ).

This script:
  1. Reads an existing biofilm_3tooth INP (dh_baseline late-time and
     commensal_static late-time already generated by p0b_long_sim_runner.py).
  2. Post-processes each INP to replace the *Cload block with a *Boundary
     block that prescribes an inward-normal displacement (δ = --disp mm) on
     ALL_OUTER nodes (computed radially from tooth centroid).
  3. Runs Abaqus for each modified INP.
  4. Extracts ODB statistics and plots:
       - BCFig1: MISES violin comparison (disp-ctrl vs force-ctrl)
       - BCFig2: Displacement violin comparison
       - BCFig3: Ratio summary bar chart

Usage
-----
  python3 p10_bc_sensitivity.py [--disp 0.001] [--dry-run]
"""
import argparse
import os
import re
import csv
import subprocess
import numpy as np
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

_HERE   = os.path.dirname(os.path.abspath(__file__))
_ABAQUS = "/home/nishioka/DassaultSystemes/SIMULIA/Commands/abaqus"
_EXTRACT = os.path.join(_HERE, "odb_extract.py")
_OUT_DIR = os.path.join(_HERE, "_bc_sensitivity")

# Late-time INPs generated by p0b_long_sim_runner.py
_INP_ARCHIVE = os.path.join(_HERE, "_job_archive", "biofilm_3tooth", "inp_variants")
_INP_BASE = {
    "dh_baseline":      os.path.join(_INP_ARCHIVE, "biofilm_3tooth_dh_baseline_late.inp"),
    "commensal_static": os.path.join(_INP_ARCHIVE, "biofilm_3tooth_commensal_static_late.inp"),
}

# Existing force-ctrl ODB element CSVs for reference
_EXTRACTED = os.path.join(_HERE, "_abaqus_extracted", "standard_3d")
_FORCE_ELEM_CSV = {
    "dh_baseline":      os.path.join(_EXTRACTED, "odb_elements_dh_baseline_late.csv"),
    "commensal_static": os.path.join(_EXTRACTED, "odb_elements_commensal_static_late.csv"),
}
_FORCE_NODE_CSV = {
    "dh_baseline":      os.path.join(_EXTRACTED, "odb_nodes_dh_baseline_late.csv"),
    "commensal_static": os.path.join(_EXTRACTED, "odb_nodes_commensal_static_late.csv"),
}

COND_COLORS = {
    "dh_baseline":     "#d62728",
    "commensal_static": "#2ca02c",
}
COND_LABELS = {
    "dh_baseline":     "DH-baseline (dysbiotic)",
    "commensal_static": "Commensal-static",
}


# ── INP parsing ───────────────────────────────────────────────────────────────

def parse_inp_nodes(inp_path):
    """Return dict label -> (x,y,z) for all nodes in the INP."""
    nodes = {}
    in_node = False
    with open(inp_path) as f:
        for line in f:
            line = line.rstrip()
            if not line or line.startswith("**"):
                continue
            if line.startswith("*"):
                kw = line.split(",")[0].strip().upper()
                in_node = (kw == "*NODE")
                continue
            if in_node:
                parts = line.split(",")
                if len(parts) >= 4:
                    try:
                        lbl = int(parts[0])
                        nodes[lbl] = (float(parts[1]),
                                      float(parts[2]),
                                      float(parts[3]))
                    except ValueError:
                        pass
    return nodes


def parse_inp_nsets(inp_path):
    """Return dict setname -> list[node_label]."""
    nsets = {}
    cur   = None
    with open(inp_path) as f:
        for line in f:
            line = line.rstrip()
            if not line or line.startswith("**"):
                continue
            if line.startswith("*"):
                kw = line.split(",")[0].strip().upper()
                if kw == "*NSET":
                    # parse name
                    m = re.search(r"NSET\s*=\s*([^,\s]+)", line, re.I)
                    cur = m.group(1) if m else None
                    if cur and cur not in nsets:
                        nsets[cur] = []
                else:
                    cur = None
                continue
            if cur is not None:
                for tok in line.split(","):
                    tok = tok.strip()
                    if tok:
                        try:
                            nsets[cur].append(int(tok))
                        except ValueError:
                            pass
    return nsets


def build_disp_bc_inp(inp_path, out_path, delta_mm):
    """
    Copy inp_path → out_path, replacing the *Cload block with a *Boundary
    block that prescribes inward-radial displacement δ = delta_mm mm on
    ALL_OUTER nodes of T23 (crown) and zero-displacement on ALL_OUTER of
    T30/T31 (slit teeth, kept at current force-ctrl value ≈ 0).

    Inward normal is estimated as (centroid - node) / |centroid - node|
    using the centroid of ALL_INNER nodes of each tooth.
    """
    print(f"  Parsing INP nodes and sets from {os.path.basename(inp_path)} ...")
    nodes   = parse_inp_nodes(inp_path)
    nsets   = parse_inp_nsets(inp_path)

    # Find ALL_INNER nodes per tooth for centroid estimation
    tooth_inner = {}
    tooth_outer = {}
    for sname, labels in nsets.items():
        for tooth in ["T23", "T30", "T31"]:
            if sname.startswith(tooth + "_INNER") or sname == "ALL_INNER":
                tooth_inner.setdefault(tooth, []).extend(labels)
            if sname.startswith(tooth + "_OUTER") or sname == "ALL_OUTER":
                tooth_outer.setdefault(tooth, []).extend(labels)

    # Use ALL_INNER/ALL_OUTER if per-tooth sets not found
    all_inner = nsets.get("ALL_INNER", [])
    all_outer = nsets.get("ALL_OUTER", [])

    # Compute centroid from ALL_INNER
    if all_inner:
        pts = np.array([nodes[n] for n in all_inner if n in nodes])
        centroid = pts.mean(axis=0)
    else:
        pts = np.array(list(nodes.values()))
        centroid = pts.mean(axis=0)
    print(f"    Centroid (from ALL_INNER): ({centroid[0]:.2f}, {centroid[1]:.2f}, {centroid[2]:.2f})")
    print(f"    ALL_OUTER nodes: {len(all_outer)}")

    # Collect Tie slave (APPROX) nodes to exclude from displacement BC
    tie_slave_nodes = set()
    for sname, labels in nsets.items():
        if "APPROX" in sname.upper():
            tie_slave_nodes.update(labels)
    print(f"    Excluding {len(tie_slave_nodes)} Tie-slave (APPROX) nodes from disp BC")

    # Build displacement BC lines
    bc_lines = []
    bc_lines.append("** Displacement-controlled BC: inward normal δ = %.4f mm\n" % delta_mm)
    bc_lines.append("** Applied to ALL_OUTER minus APPROX (Tie slave) nodes\n")
    bc_lines.append("*Boundary\n")
    n_applied = 0
    for n_lbl in sorted(all_outer):
        if n_lbl not in nodes:
            continue
        if n_lbl in tie_slave_nodes:
            continue   # skip Tie slave nodes — overconstrained
        coord = np.array(nodes[n_lbl])
        vec   = centroid - coord
        dist  = np.linalg.norm(vec)
        if dist < 1e-12:
            continue
        n_hat = vec / dist          # inward unit normal (toward centroid)
        ux = delta_mm * n_hat[0]
        uy = delta_mm * n_hat[1]
        uz = delta_mm * n_hat[2]
        bc_lines.append(" %d, 1, 1, %.6e\n" % (n_lbl, ux))
        bc_lines.append(" %d, 2, 2, %.6e\n" % (n_lbl, uy))
        bc_lines.append(" %d, 3, 3, %.6e\n" % (n_lbl, uz))
        n_applied += 1
    print(f"    BC applied to {n_applied} free OUTER nodes")

    # Copy INP, replacing *Cload block with displacement BC
    in_cload = False
    written  = False
    with open(inp_path) as fin, open(out_path, "w") as fout:
        for line in fin:
            stripped = line.strip()
            if stripped.upper().startswith("*CLOAD"):
                in_cload = True
                if not written:
                    fout.writelines(bc_lines)
                    written = True
                continue
            if in_cload:
                # Skip Cload data lines until next keyword
                if stripped.startswith("*") and not stripped.startswith("**"):
                    in_cload = False
                    fout.write(line)
                continue
            fout.write(line)

    print(f"  Displacement-controlled INP written: {os.path.basename(out_path)}")
    print(f"  BC lines: {len(bc_lines)}")
    return out_path


# ── ODB extract & stats ───────────────────────────────────────────────────────

def run_abaqus(job, inp, out_dir, cpus=4):
    cmd = [_ABAQUS, f"job={job}", f"input={inp}",
           f"cpus={cpus}", "ask=off", "interactive"]
    print(f"  $ {' '.join(cmd)}")
    ret = subprocess.run(cmd, cwd=out_dir)
    return ret.returncode


def extract_odb(odb_path, out_dir):
    cmd = [_ABAQUS, "python", _EXTRACT, odb_path]
    print(f"  Extracting ODB: {os.path.basename(odb_path)}")
    subprocess.run(cmd, cwd=out_dir)
    raw_e = os.path.join(out_dir, "odb_elements.csv")
    raw_n = os.path.join(out_dir, "odb_nodes.csv")
    return raw_e if os.path.exists(raw_e) else None, \
           raw_n if os.path.exists(raw_n) else None


def read_mises(elem_csv):
    mises = []
    with open(elem_csv) as f:
        reader = csv.DictReader(f)
        for row in reader:
            try:
                mises.append(float(row["mises"]))
            except (KeyError, ValueError):
                pass
    return np.array(mises)


def read_umag(node_csv):
    umag = []
    with open(node_csv) as f:
        reader = csv.DictReader(f)
        for row in reader:
            try:
                umag.append(float(row["Umag"]))
            except (KeyError, ValueError):
                pass
    return np.array(umag)


# ── Plotting ──────────────────────────────────────────────────────────────────

def plot_comparison(force_data, disp_data, out_dir):
    """
    force_data / disp_data: dict cond -> {'mises': np.array, 'umag': np.array}
    """
    conds = list(force_data.keys())

    # BCFig1: MISES violin
    fig, axes = plt.subplots(1, 2, figsize=(12, 6), sharey=False)
    for ax, (bc_type, bc_data) in zip(axes, [("Force-controlled", force_data),
                                              ("Displacement-controlled", disp_data)]):
        parts = ax.violinplot(
            [np.log10(bc_data[c]["mises"] + 1e-12) for c in conds],
            positions=range(len(conds)), showmedians=True)
        for pc, c in zip(parts["bodies"], conds):
            pc.set_facecolor(COND_COLORS[c])
            pc.set_alpha(0.7)
        ax.set_xticks(range(len(conds)))
        ax.set_xticklabels([COND_LABELS[c] for c in conds], rotation=15, ha="right")
        ax.set_ylabel("log₁₀(MISES / MPa)")
        ax.set_title(f"MISES — {bc_type}")
        ax.grid(True, alpha=0.3, axis="y")
    fig.suptitle("P10 BC Sensitivity: von Mises stress\n"
                 "(Force BC → stress same; Disp BC → stress ∝ E_eff)",
                 fontsize=12)
    fig.tight_layout()
    p = os.path.join(out_dir, "BCFig1_mises_comparison.png")
    fig.savefig(p, dpi=150)
    plt.close(fig)
    print(f"  Saved: {p}")

    # BCFig2: |U| violin
    fig, axes = plt.subplots(1, 2, figsize=(12, 6), sharey=False)
    for ax, (bc_type, bc_data) in zip(axes, [("Force-controlled", force_data),
                                              ("Displacement-controlled", disp_data)]):
        parts = ax.violinplot(
            [bc_data[c]["umag"] * 1e3 for c in conds],   # mm → µm
            positions=range(len(conds)), showmedians=True)
        for pc, c in zip(parts["bodies"], conds):
            pc.set_facecolor(COND_COLORS[c])
            pc.set_alpha(0.7)
        ax.set_xticks(range(len(conds)))
        ax.set_xticklabels([COND_LABELS[c] for c in conds], rotation=15, ha="right")
        ax.set_ylabel("|U| (µm)")
        ax.set_title(f"Displacement — {bc_type}")
        ax.grid(True, alpha=0.3, axis="y")
    fig.suptitle("P10 BC Sensitivity: displacement\n"
                 "(Force BC → |U| ∝ 1/E_eff; Disp BC → |U| prescribed = const)",
                 fontsize=12)
    fig.tight_layout()
    p = os.path.join(out_dir, "BCFig2_displacement_comparison.png")
    fig.savefig(p, dpi=150)
    plt.close(fig)
    print(f"  Saved: {p}")

    # BCFig3: ratio bar chart
    fig, axes = plt.subplots(1, 2, figsize=(10, 5))
    metrics = [
        ("MISES median ratio\n(DH-baseline / Commensal)", "mises"),
        ("|U| median ratio\n(DH-baseline / Commensal)", "umag"),
    ]
    for ax, (ylabel, key) in zip(axes, metrics):
        for bc_type, bc_data, color, xpos in [
                ("Force", force_data, "#1f77b4", 0),
                ("Disp",  disp_data,  "#ff7f0e", 1)]:
            dh = np.median(bc_data["dh_baseline"][key])
            cs = np.median(bc_data["commensal_static"][key])
            ratio = dh / cs if cs > 0 else 0
            ax.bar(xpos, ratio, color=color, edgecolor="k",
                   label=f"{bc_type}-ctrl")
            ax.text(xpos, ratio + 0.05, f"{ratio:.1f}×",
                    ha="center", fontsize=12, fontweight="bold")
        ax.axhline(1.0, color="k", linestyle="--", alpha=0.5)
        ax.set_ylabel(ylabel)
        ax.set_xticks([0, 1])
        ax.set_xticklabels(["Force-ctrl", "Disp-ctrl"])
        ax.set_title(ylabel.replace("\n", " "))
        ax.legend()
        ax.grid(True, alpha=0.3, axis="y")
    fig.suptitle("P10 BC Sensitivity: DH-baseline / Commensal-static ratios\n"
                 "Force-ctrl: |U| ≈ 19.7× ; MISES ≈ 1×\n"
                 "Disp-ctrl: MISES ≈ E_dh/E_cs ≈ 0.051× ; |U| ≈ 1×",
                 fontsize=11)
    fig.tight_layout()
    p = os.path.join(out_dir, "BCFig3_ratio_summary.png")
    fig.savefig(p, dpi=150)
    plt.close(fig)
    print(f"  Saved: {p}")


# ── main ──────────────────────────────────────────────────────────────────────

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--disp",    type=float, default=0.001,
                    help="Prescribed inward displacement (mm) [0.001]")
    ap.add_argument("--cpus",    type=int,   default=4)
    ap.add_argument("--dry-run", action="store_true")
    ap.add_argument("--out-dir", default=_OUT_DIR)
    args = ap.parse_args()

    os.makedirs(args.out_dir, exist_ok=True)
    fig_dir = os.path.join(_HERE, "figures")
    os.makedirs(fig_dir, exist_ok=True)

    print("=" * 60)
    print("  P10 BC Sensitivity Study")
    print(f"  Prescribed displacement: {args.disp} mm = {args.disp*1e3:.1f} µm")
    print("=" * 60)

    # ── Step 1: Generate displacement-controlled INPs ─────────────────────────
    disp_elem_csv = {}
    disp_node_csv = {}

    for cond, inp_path in _INP_BASE.items():
        if not os.path.exists(inp_path):
            print(f"  [warn] INP not found: {inp_path} — skipping {cond}")
            continue

        disp_inp = os.path.join(args.out_dir,
                                f"biofilm_{cond}_disp.inp")
        build_disp_bc_inp(inp_path, disp_inp, args.disp)

        if args.dry_run:
            print(f"  [dry-run] Skipping Abaqus for {cond}")
            continue

        # ── Step 2: Run Abaqus ───────────────────────────────────────────────
        job = f"BioFilm3T_{cond}_disp"
        odb = os.path.join(args.out_dir, f"{job}.odb")
        rc  = run_abaqus(job, disp_inp, args.out_dir, cpus=args.cpus)
        if rc != 0 or not os.path.exists(odb):
            print(f"  [error] Abaqus failed for {cond} (rc={rc})")
            continue

        # ── Step 3: Extract ODB ──────────────────────────────────────────────
        raw_e, raw_n = extract_odb(odb, args.out_dir)
        if raw_e and raw_n:
            elbl = os.path.join(args.out_dir, f"odb_elements_{cond}_disp.csv")
            nlbl = os.path.join(args.out_dir, f"odb_nodes_{cond}_disp.csv")
            os.replace(raw_e, elbl)
            os.replace(raw_n, nlbl)
            disp_elem_csv[cond] = elbl
            disp_node_csv[cond] = nlbl
            mises = read_mises(elbl)
            umag  = read_umag(nlbl)
            print(f"  {cond}: MISES median={np.median(mises):.4f} MPa  "
                  f"|U| median={np.median(umag)*1e3:.3f} µm")

    if args.dry_run:
        print("\n[dry-run] INP generation done. Run without --dry-run for Abaqus.")
        return

    # ── Step 4: Load force-controlled reference CSVs ──────────────────────────
    force_data = {}
    disp_data  = {}

    for cond in ["dh_baseline", "commensal_static"]:
        # Force ctrl
        fc_e = _FORCE_ELEM_CSV[cond]
        fc_n = _FORCE_NODE_CSV[cond]
        if os.path.exists(fc_e) and os.path.exists(fc_n):
            force_data[cond] = {
                "mises": read_mises(fc_e),
                "umag":  read_umag(fc_n),
            }
        else:
            print(f"  [warn] Force-ctrl CSVs not found for {cond}")

        # Disp ctrl
        dc_e = disp_elem_csv.get(cond)
        dc_n = disp_node_csv.get(cond)
        if dc_e and dc_n and os.path.exists(dc_e) and os.path.exists(dc_n):
            disp_data[cond] = {
                "mises": read_mises(dc_e),
                "umag":  read_umag(dc_n),
            }
        else:
            print(f"  [warn] Disp-ctrl CSVs not found for {cond}")

    if len(force_data) < 2 or len(disp_data) < 2:
        print("[info] Incomplete data — cannot generate comparison figures.")
        return

    # ── Step 5: Plot ──────────────────────────────────────────────────────────
    plot_comparison(force_data, disp_data, fig_dir)
    print("\nDone. Figures saved in figures/BCFig1–3.")


if __name__ == "__main__":
    main()
